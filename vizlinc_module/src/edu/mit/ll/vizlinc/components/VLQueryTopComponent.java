/*
 * 
 */
package edu.mit.ll.vizlinc.components;

import edu.mit.ll.vizlinc.model.DBManager;
import edu.mit.ll.vizlinc.model.FacetValue;
import edu.mit.ll.vizlinc.model.KeywordEntity;
import edu.mit.ll.vizlinc.model.KeywordValue;
import edu.mit.ll.vizlinc.model.LocationValue;
import edu.mit.ll.vizlinc.model.OrganizationValue;
import edu.mit.ll.vizlinc.model.PersonValue;
import edu.mit.ll.vizlinc.model.VLQueryListener;
import edu.mit.ll.vizlinc.ui.elements.FacetValueTransferable;
import edu.mit.ll.vizlinc.utils.UIUtils;
import edu.mit.ll.vizlincdb.document.Document;
import java.awt.Font;
import java.io.File;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.TransferHandler;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;

/**
 * Top component which displays query
 */
@ConvertAsProperties(
    dtd = "-//edu.mit.ll.vizlinc.components//VLQuery//EN",
autostore = false)
@TopComponent.Description(
    preferredID = "VLQueryTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "explorer", openAtStartup = true)
@ActionID(category = "Window", id = "edu.mit.ll.vizlinc.components.VLQueryTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
    displayName = "#CTL_VLQueryAction",
preferredID = "VLQueryTopComponent")
@Messages(
{
    "CTL_VLQueryAction=VLQuery",
    "CTL_VLQueryTopComponent=Query",
    "HINT_VLQueryTopComponent=This is a VLQuery window"
})
public final class VLQueryTopComponent extends TopComponent implements VLQueryListener
{

    private FilterStack filterStack;
    private ImageIcon personIcon = null;
    private ImageIcon locationIcon = null;
    private ImageIcon organizationIcon = null;
    private ImageIcon docNameIcon = null;
    private ImageIcon docTextIcon = null;
    private FacetedSearchTopComponent facetedSearchWin = null;
    private static final String FILTERS_NONE_STR = "Filters: None";
    private static final String FILTERS_STR = "Filters:";
    private boolean newFilterPushed;
            
    public VLQueryTopComponent()
    {
        if(!DBManager.getInstance().isReady())
        {
            return;
        }
        
        initComponents();
        setName(Bundle.CTL_VLQueryTopComponent());
        setToolTipText(Bundle.HINT_VLQueryTopComponent());
        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_DRAGGING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_MAXIMIZATION_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_SLIDING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_UNDOCKING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_KEEP_PREFERRED_SIZE_WHEN_SLIDED_IN, Boolean.FALSE);

        //Private fields
        this.filterStack = new FilterStack();
        
        //Support paste of entities from facet tree
        setTransferHandler(new DropFromFacetTreeTransferHandler2());
        //Register as a listener
        final VLQueryListener thisAsAListener = this;
        WindowManager.getDefault().invokeWhenUIReady(new Runnable()
        {
            @Override
            public void run()
            {
               facetedSearchWin = UIUtils.getFacetedSearchWindow();
               
               if(facetedSearchWin != null)
               {
                    //Register as a VLQueryListener 
                    facetedSearchWin.addQueryListener(thisAsAListener);
               }
            }
        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        filterPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jButtonSelect = new javax.swing.JButton();

        jScrollPane1.setBorder(null);

        filterPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, FILTERS_STR);
        filterPanel.add(jLabel1);

        jScrollPane1.setViewportView(filterPanel);

        org.openide.awt.Mnemonics.setLocalizedText(jButtonSelect, org.openide.util.NbBundle.getMessage(VLQueryTopComponent.class, "VLQueryTopComponent.jButtonSelect.text")); // NOI18N
        jButtonSelect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSelectActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButtonSelect)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 301, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButtonSelect)
                        .addContainerGap(279, Short.MAX_VALUE))))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonSelectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSelectActionPerformed
        facetedSearchWin.selectFacetValues(getNonKeywordFilters());
    }//GEN-LAST:event_jButtonSelectActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel filterPanel;
    private javax.swing.JButton jButtonSelect;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened()
    {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed()
    {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p)
    {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p)
    {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
    
    /**
     * 
     * @return filters (query items) in query
     */
    public List<FacetValue> getFilters()
    {
        return this.filterStack.getFacetValueList();
    }

    /**
     * Deletes last filter added from filter stack
     * 
     * @return 
     */
    boolean pop()
    {
        boolean popped = this.filterStack.pop();
        if(popped)
        {
            displayStackStateUI();
        }
        return popped;
    }

    boolean isEmpty()
    {
        return this.filterStack.isEmpty();
    }

    void clear()
    {
        this.filterStack.clear();
        displayStackStateUI();
    }

    /**
     * Add filter to filter stack
     * @param fv
     * @return 
     */
    boolean pushFilter(final FacetValue fv)
    {
        
        this.newFilterPushed = this.filterStack.pushFilter(fv);
        if(newFilterPushed)
        {
            displayStackStateUI();
        }
        
        return newFilterPushed;
    }
    
    public boolean wasNewFilterPushed()
    {
        return this.newFilterPushed;
    }
    
    //TODO: Too many methods creating/getting icons. Consolidate this with UIUtils.getIconPath()
    //and have a global icon registry to reuse icons.
    private ImageIcon getCorrespondingIcon(FacetValue fv)
    {
        if(fv instanceof PersonValue)
        {
            if(personIcon == null)
            {
                personIcon = new ImageIcon(UIUtils.getIconPath(fv));
            }
            return personIcon;
        }
        else if(fv instanceof LocationValue)
        {
            if(locationIcon == null)
            {
                locationIcon  = new ImageIcon(UIUtils.getIconPath(fv));
            }
            return locationIcon;
        }
        else if(fv instanceof OrganizationValue)
        {
            if(organizationIcon == null)
            {
                organizationIcon = new ImageIcon(UIUtils.getIconPath(fv));
            }
            return organizationIcon;
        }
        else if(fv instanceof KeywordValue)
        {
            //Determine type
            int type = ((KeywordValue) fv).getField();
            if(type == KeywordEntity.FIELD_DOC_NAME)
            {
                if(docNameIcon == null)
                {
                    docNameIcon = new ImageIcon(UIUtils.getIconDir() + File.separator + "doc_name.png");
                }
                return docNameIcon;
            }
            else
            {
                if(docTextIcon == null)
                {
                    docTextIcon = new ImageIcon(UIUtils.getIconDir() + File.separator + "doc_text.png");
                }
                return docTextIcon;
            }
        }
        
        return null;
    }
    
    public List<FacetValue> getNonKeywordFilters()
    {
        return this.filterStack.getNonKeywordEntities();
    }
    
    public List<KeywordValue> getKeywordFilters()
    {
        return this.filterStack.getKeywordEntities();
    }

    public List<PersonValue> getPersonFilters()
    {
        return this.filterStack.getPersonEntities();
    }

    private void displayStackStateUI()
    {
        //Update UI to reflect state of stack
        filterPanel.removeAll();
        String filterLabelStr;
        if (filterStack.isEmpty())
        {
            filterLabelStr = FILTERS_NONE_STR;
        } else
        {
            filterLabelStr = FILTERS_STR;
        }
        //Add header
        JLabel filterLabel = new JLabel(filterLabelStr);
        filterLabel.setFont(filterLabel.getFont().deriveFont(Font.BOLD));
        filterPanel.add(filterLabel);

        boolean first = true;
        for (FacetValue fv : filterStack.getFacetValueList())
        {
            if(first)
            {
                first = false;
            }
            else
            {
                JLabel andLabel = new JLabel("&");
                andLabel.setFont(andLabel.getFont().deriveFont(Font.BOLD));
                filterPanel.add(andLabel);
            }
            ImageIcon icon = getCorrespondingIcon(fv);
            JLabel label = new JLabel(fv.getText(), icon, JLabel.LEFT);
            label.setVerticalTextPosition(JLabel.CENTER);
            label.setHorizontalAlignment(JLabel.RIGHT);
            filterPanel.add(label);
        }
        invalidate();
        validate();
        repaint();
    }

    @Override
    public void aboutToExecuteQuery()
    {
        //Do nothing...
    }

    @Override
    public void queryFinished(List<Document> documents, List<LocationValue> locationsInFacetTree, List<PersonValue> peopleInFacetTree)
    {
        this.newFilterPushed = false;
    }

    /**
     * Holds filters in a stack data structure
     */
    private class FilterStack
    {
        private List<FacetValue> filters;

        public FilterStack()
        {
            this.filters = new LinkedList<FacetValue>();
        }

        public boolean pushFilter(FacetValue fv)
        {
            if(filters.contains(fv))
            {
                return false;
            }
            
            this.filters.add(fv);
            return true;
        }

        /**
         * Returns a copy of the facet list. It is not a deep copy, as elements
         * are references to the ones in the original list.
         *
         * @return
         */
        public List<FacetValue> getFacetValueList()
        {
            return new ArrayList<FacetValue>(this.filters);
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder();
            boolean first = true;
            for (FacetValue val : filters)
            {
                if (!first)
                {
                    sb.append(" >> ");
                }
                sb.append(val.getType()).append(":").append(val.getText());
                first = false;
            }
            return sb.toString();
        }

        private boolean pop()
        {
            if (this.filters.isEmpty())
            {
                return false;
            }
            this.filters.remove(filters.size() - 1);
            return true;
        }

        public boolean isEmpty()
        {
            return this.filters.isEmpty();
        }

        private void clear()
        {
            filters.clear();
        }

        private List<FacetValue> getNonKeywordEntities()
        {
            List<FacetValue> result = new LinkedList<FacetValue>();
            for (FacetValue e : this.filters)
            {
                if (!(e instanceof KeywordValue))
                {
                    result.add(e);
                }
            }
            return result;
        }

        private List<KeywordValue> getKeywordEntities()
        {
            List<KeywordValue> result = new LinkedList<KeywordValue>();
            for (FacetValue e : this.filters)
            {
                if (e instanceof KeywordValue)
                {
                    result.add((KeywordValue) e);
                }
            }
            return result;
        }
        
        private List<PersonValue> getPersonEntities()
        {
            List<PersonValue> result = new LinkedList<PersonValue>();
            for (FacetValue e : this.filters)
            {
                if (e instanceof PersonValue)
                {
                    result.add((PersonValue) e);
                }
            }
            return result;
        }
    }
        

public class DropFromFacetTreeTransferHandler2 extends TransferHandler
    {

        public DropFromFacetTreeTransferHandler2()
        {
        }

        @Override
        public boolean canImport(TransferHandler.TransferSupport support)
        {
            //Drops on this window only suppor FacetValueFlavor
            if(!support.isDataFlavorSupported(FacetValueTransferable.facetValueFlavor))
            {
                return false;
            }
            
            return true;
        }

        @Override
        public boolean importData(TransferHandler.TransferSupport support)
        {
            if(!support.isDrop())
            {
                return false;
            }
            
            FacetValue fv;
            try
            {
                fv = (FacetValue)support.getTransferable().getTransferData(FacetValueTransferable.facetValueFlavor);
            } catch (Exception ex)
            {
                Exceptions.printStackTrace(ex);
                UIUtils.reportException(UIUtils.getFirstParentComponent(support.getComponent()), ex);
                return false;
            }
            
            pushFilter(fv);
            return true;
        }
    }
}
